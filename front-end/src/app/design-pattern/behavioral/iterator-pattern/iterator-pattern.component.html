<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Iterator Pattern - Behavioral Pattern</h2>

      <p>Cung cấp 1 cách thức đểcó thể truy cập các phần tử của một đối tượng một cách tuần tự mà không để lộ đại diện cơ
      bản của nó.</p>

      <p>Chuẩn hóa các lớp abstract cho phép tách rời các thuật toán khỏi các collection.</p>

      <p>Cung cấp 1 "full object status" đến traveral collection</p>

      <p>Polymorphic traversal</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Quay lại nhà hàng góc phố. Hôm nay ông chủ quyết định xây dựng một menu thực đơn mới để phục vụ người dùng tốt hơn.</p>

        <p>Menu của ông tổng hợp lại những món ăn mà nhà hàng có thể phục vụ. Những người khách cứ việc đến, tìm kiếm và
          gọi món rồi một lát sau sẽ được phục vụ liền.</p>

        <p>Tuy nhiên, để cho dễ nhìn và dễ nhận biết, dưới mỗi món ăn ông đầu bếp sẽ phân loại món á hay âu, món chay hay
          mặn, món điểm tâm hay ăn chính.</p>

        <p>Thế rồi có một ngày một gia đình ngoại quốc vào nhà hàng ông ăn. Nhưng mà có sự khác biệt. Bà mẹ thì theo đạo
          Phật chỉ ăn chay ko ăn thịt, ông bố thì
          theo đạo Hồi, ko chịu ăn bò, và cậu con của họ thì cái gì cũng xơi tuốt. Bàn đông nên chỉ còn 1 quyển sổ, và
          vậy là gia đình kia mất cả buổi cũng ko thể tìm được món ăn mà mình cần giữa một đống danh mục ngổn ngang.</p>

      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Bởi vì thực đơn chỉ được phân loại theo một quy tắc mà ông chủ đã đặt ra nên nó trở nên cứng nhắc đối với
          người dùng khi họ muốn tìm kiếm.</p>

        <p>Thế là ông chủ quyết định cho anh phục vụ nguyên một ngày để học các món ăn, khi khách tới, tùy vào yêu cầu
          mà anh ấy có thể tìm kiếm cho vị khách những món phù hợp với mong muốn của họ.</p>

        <p>Trong bài toán này, anh phục vụ (sau khi đã đc đào tạo nhé) là iterator.</p>

        <p>Iterator Pattern ra đời để giải quyết bài toán duyệt qua các phần tử của mảng mà không quan
          tâm tới bản chất các phần tử.</p>

        <p>Nếu đã từng làm với Java, thì chắc chả ai là ko biết tới cái Hash Map. Và một trong số những
          cách duyệt qua các phần tử của Hash Map cũng được sử dụng 1 cái gọi là iterator. Chính xác thì hashmap là 1 ví dụ của
        việc implement Iterator Pattern trong Java.</p>

        <blockquote>
          Iterator it = mp.entrySet().iterator();<br/>
          while (it.hasNext()) {{'{'}}<br/>
          &nbsp; &nbsp; Map.Entry pair = (Map.Entry)it.next();<br/>
          &nbsp; &nbsp; System.out.println(pair.getKey() + " = " + pair.getValue());<br/>
          &nbsp; &nbsp; it.remove(); // avoids a ConcurrentModificationException<br/>
          }<br/>
        </blockquote>

        <p>Iterator with array list.</p>

        <blockquote>

          Iterator&lt;String> iterator = list.iterator();
          while (iterator.hasNext()) {{'{'}}
          &nbsp; &nbsp; System.out.println(iterator.next());
          }
        </blockquote>

        <p>Và trong trường hợp này anh phục vụ cũng vậy, anh có thể lấy ra được danh sách các món ăn theo yêu cầu, mà ko cần
          quan tâm tới bản chất của món ăn đó ntn, là chay hay mặn, là ngọt hay béo ....</p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">
        <blockquote>
          to access the elements of an aggregate object sequentially without exposing its underlying implementation".
        </blockquote>

        <blockquote>
          The Iterator pattern is also known as Cursor.
        </blockquote>

        <p>Trong một hệ thống, đôi khi ta cần phải xây dựng những collection. Những collection này có thể được xây dựng
        bằng những cách thức khác nhau, do đó, nếu muốn duyệt/travesal nhũng collection này, ta cần xây dựng các phương thức
        phù hợp với nó.</p>


        <p>Một đối tượng tổng hợp như 1 list sẽ cung cấp cho ta cách thức truy cập các phần tử của nó mà không để lộ cấu trúc
          bên trong nó. Ngoài ra, ta có thể muốn duyệt qua danh sách với các cách thức khác nhau, tùy thuộc vào những gì cần thực hiện.</p>

        <p>Tuy nhiên, điều đó là không hay lắm nếu có quá nhiều collection và ta không biết được cần áp dụng chính xác cách thức nào. </p>

        <p>Interator cung cấp 1 chuẩn hóa/standard định ra các quy tắc, cung cấp 1 giao diện thống nhất để duyệt qua nhiều loại đối
        tượng tổng hợp (đa hình).</p>

        <p>Ý tưởng của Iterator đó là nó nhận trách nhiệm truy cập và duyệt ra khỏi dối tượng tổng hợp, đưa nó vào 1 đối tượng
        Iterator xác định với 1 giao thức duyệt tiêu chuẩn.</p>

        <p>Sự trừu tượng hóa của Iterator là nền tảng cho 1 công nghệ mới nổi là generic programming. Chiến lược này
        tìm cách tách biệt rõ ràng khái niệm thuật toán với cấu trúc dữ liệu. Điều này sẽ thúc đẩy việc hát triển dựa vào component-base
        development và giảm số configuration management.</p>

        <p>Một ví dụ cho điều nà, nếu ta muốn support 4 loại dữ liệu như array, binary tree, linked list và hast table và 3 thuật toán
        sort, find và merge, theo sự tiếp cận truyền thống ta sẽ cần 4 x 3 = 12 function cần tạo. Trong khi nếu sử dụng Generic
        thì ta chỉ cần 4 + 3 chức năng.</p>

        <p class="small-text">
          với mỗi array ta cần implement đủ  3 cái function trên. Nên theo cách truyền thống ta cần 4 x 3 = 12.
          Với Generic Programming, cụ thể Iterator, ta chỉ cần implement 3 method cho toàn bộ tụi này và 4 vòng duyệt.
        </p>

      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">
        <p>Để implement 1 Iterator cần thực hiện các step sau:</p>

        <ol>
          <li>Thêm 1 phương thức create_iterator vào collection class, và cấp quyền truy cập đặc quyền cho nó.</li>
          <li>Thiết kế 1 lớp iterator có thể gói gọn việc duyệt qua các phần tử của collection class</li>
          <li>Clients yêu cầu collection class tạo đối tượng iterator.</li>
          <li>Client sử dụng first(), isDone(), next() và các protocol khác để truy câp các phần tử của collection class.</li>
        </ol>

        <p>Client sử dụng các collection interface để duyệt qua các phần tử của Object. Tuy nhiên, quyền truy cập trực tiếp vào các element
        bên trong collection được đóng gói bên trong 1 Abstract Class bổ sung - Iterator. Mỗi lớp dẫn xuất bộ sưu tập biết Itegration
        nào sẽ được tạo và trả về. Sau đó, Client dựa vào các interface được define trong Iterator base class.</p>

        <ul>
          <li>Một Collection Interface để define những thuộc tính chung của nó:
            <ul>
              <li>addElement(Element)</li>
              <li>removeElement(Element)</li>
              <li>iterator (params)</li>
            </ul>
          </li>

          <li>Một Iterator cho Collection đó:
            <ul>
              <li>boolean hasNext()</li>
              <li>Element  next()</li>
            </ul>
          </li>

          <li>Các collection implement nó.</li>
        </ul>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages
      </div>

      <div class="card-body">
        <h5>Advantages</h5>

        <p>Cung cấp 1 cơ chế duyệt qua các phần tử của 1 collection bất kì, đồng thời hỗ trợ các biến thể cho việc filter/ iterator</p>

        <p>Đơn giản hóa giao diện cho collection.</p>


        <h5>Usage</h5>

        <p>Khi ta muốn truy cập vào 1 collection mà không để lộ đại diện bên trong của nó</p>

        <p>Khi có nhiều đối tượng cần được hỗ trợ trong collection.</p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Summary
      </div>

      <div class="card-body">
        <p>Xem lại về Interpreter, ta thấy abstract syntax tree của nó là composite. Do đó, ta cũng có thể áp dụng Iterator vầ Visitor thay thế.</p>

        <p>Iterator có thể duyệt 1 Composite. Visitor có thể áp dụng hoạt động lên 1 Composite.</p>

        <p>Polymophic Iterator dựa trên các Factory Method để tạo ra các Iterator thích hợp</p>

        <p>Memento thường được kết hợp với Iterator. Một Iterator có thể sử dụng Memetor để lưu trữ trạng thái của 1 lần
          Lặp. Iterator lưu trữ Memeto trong nội bộ/ bên trong nó.</p>
      </div>
    </div>
  </div>
</div>
