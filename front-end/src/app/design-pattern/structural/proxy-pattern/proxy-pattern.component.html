<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Proxy Pattern - Structural Pattern</h2>

      <p>Cung cấp người thay thế (surogate) hoặc người giữ chỗ (placeholder) cho 1 đối tượng khác để kiểm soát quyền truy cập vào
        đối tượng đó.</p>

      <p>Sử dụng 1 extra level của indirection để hỗ trợ distributed, controller, hoặc truy cập thông minh. </p>

      <p>Thêm 1 trình bao bọc và ủy quyền để hỗ trợ component khỏi sự phức tạp không đáng có.</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Hôm nay ta tạm thời rời xa cửa hàng góc phố, để sang văn phòng luật sư đối diện.</p>

        <p>Văn phòng luật sư đối diện đang có một khách hàng. Đó là một người phụ nữ. Cô ấy có một cuộc
          sống không hạnh phúc và quyết định ly hôn chồng.</p>

        <p>Tuy nhiên, cô lại không hiểu rõ về luật pháp, không biết các thủ tục, cũng ko biết làm thế nào
          để có thể giành quyền nuôi con.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Vì vậy, cô đến văn phòng này, nhờ một luật sư đứng ra làm người đại diện để bảo vệ quyền lợi của mình.</p>

        <p>Luật sư trong bài viết, đó là Proxy.</p>

        <p>Proxy được dịch ra là Ủy quyền. Ủy quyền ở đây tức là ủy thác cho một người, làm người đại diện, thay mặt mình
          để thực hiện các công việc đặc biệt. Ở đây, người phụ nữ kia ủy quyền cho ông luật sư giải quyết
          tranh chấp, bởi thân chủ không đủ khả năng hiểu biết pháp luật để bảo về cho mình.</p>

        <p>Trong lập trình cũng vậy. Nhiều khi vì một vấn đề nào đó, ta cần phải sử dụng một người Ủy quyền để thực hiện
          những công việc đặc biệt. Ví dụ như truy cập vào các tài nguyên giới hạn, hay tương tự như thế.</p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">
        <blockquote>
          "provides the control for accessing the original object"
        </blockquote>

        <blockquote>
          Proxy pattern is also known as Surrogate or Placeholder.
        </blockquote>

        <p>Trong lập trình, đôi lúc ta gặp bài toán, ta cần hỗ trợ các đối tượng tài nguyên nhưng ta không hề muốn khởi
        tạo các đối tượng này trừ khi và cho đén khi nó thực sự được client yêu cầu.</p>

        <p>Proxy được dùng trong bài toán trên, bằng cách thiết kế 1 người hỗ trợ (surrogate) hoặc proxy: <br />
          Khởi tạo đối tượng thực lần đầu tiên khi Client gửi request đến prodxy. <br />
          Ghi nhớ danh tính (ID) của đối tượng này và chuyển tiếp các request tiếp theo đến nó.<br />
          Sau đó, toàn bộ các request tiếp theo chỉ đơn giản được forward trực tiếp tới đối tượng thực được đóng gói này.
        </p>

        <p>Dưới đây là 4 tình huống phổ biến mà proxy thường được áp dụng</p>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Virtual Proxy</h5>
          <div class="text-dark pt-3">
            <p>Virtual Proxy là 1 placeholder cho "expensive to create". Object chỉ được tạo tại lần đầu tiên Client
            yêu cầu/truy cập tới nó.</p>

            <p>Thông thường Virtual Proxy thường đi kèm với Object Pool hoặc Singleton để đảm bảo tiết kiệm tài nguyên và
            vẫn đảm bảo được hiệu quả cao nhất.</p>
          </div>
        </div>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Remote  Proxy</h5>
          <div class="text-dark pt-3">
            <p>Remote Proxy cung cấp 1 đại diện nội bộ cho 1 object nằm trong 1 không gian dịa chỉ khác. Nói cách khác, cái thằng này
            như là 1 nội gián, có nhiệm vụ liên lạc giữa 2 system với nhau. Để đảm bảo security thì hệ thống kia chỉ chấp nhận các request
            đến từ proxy này.</p>
          </div>
        </div>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Protected Proxy</h5>
          <div class="text-dark pt-3">
            <p>Proxy này đóng vai trò kiểm soát truy cập vào 1 đối tượng nhạy cảm. Đối tượng thay thế này cần kiểm tra Client
            có đủ quyền truy cập cần thiết trước khi chuyển tiếp yêu cầu.</p>

            <p>Ví dụ như bạn ra cây ATM rút tiền, bạn gửi request rút tiền. ATM đóng vai trò như một Proxy, thực hiện giao dịch
              của bạn với ngân hàng và sau đó sẽ trả lại tiền cho bạn.</p>

            <p>Nếu không có ATM, bạn sẽ phải chạy tới và làm việc trực tiếp với cô thu ngân. Cô thu ngân này sẽ lại vào
              kiểm tra hệ thống, vào gặp thủ quỹ lấy tiền và đưa bạn.</p>

            <p>Nếu như ko có cả 2 cô trên, bạn tự vào nhà bank, tự mở tủ, tự lấy tiền, tự cập nhật tài khoản, và nghe thế
              thôi đã rất nguy hiểm rồi phải ko.</p>
          </div>
        </div>


        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Smart Proxy </h5>
          <div class="text-dark pt-3">
            <p>Smart Proxy can thiệp các hành động bổ sung khi 1 đối tượng được truy cập.</p>

            <p>Các hình thức sử dụng điển hình:</p>

            <ul>
              <li>Đếm số lượng tham chiếu đến đối tượng thực thể đó, để quyết định giải phóng tự động khi không còn tham chiếu.
                Cách thức này còn được gọi là Smart Pointer / Smart Reference Proxy</li>

              <li>Loading 1 đối tượng lên memory khi nó được tham chiếu lần đầu. Điều này sẽ giúp tiết kiệm chi phí vì sử dụng nó
                như một cache vậy. Cái này chính là Cache Proxy ở dưới.</li>

              <li>Kiểm tra xem đối tượng có bị lock trước khi truy cập để đảm bảo rằng không có đối tượng nào có thể tham chiếu đến nó.
                Cái này hữu ích trong môi trường Multiple thread, ta muốn đảm bảo rằng 1 action xảy ra sẽ không bị can thiệp bởi 1 action khác.
              </li>
            </ul>
          </div>
        </div>

        <p>Ngoài ra còn có các hình thức sau, là bổ sung/biến thể khác của 4 cái ở trên</p>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Monitor Proxy</h5>
          <div class="text-dark pt-3">
            <p>Thiết lập các bảo mật trên đối tượng cần bảo vệ. ngăn không cho client truy cập tới một số trường quan trọng của
            đối tượng. Ngoài ra, nó còn có thể theo dõi, giám sát, ghi log việc truy cập, sử dụng đối tượng.</p>

          </div>
        </div>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Firewall Proxy</h5>
          <div class="text-dark pt-3">
            <p>Bảo vệ đối tượng khỏi các truy cập không tính nhiệm. Thông thường, firewall sẽ đi kèm với remote proxy, làm thành
            1 bức tường để đảm bảo xác thực rằng truy cập là được phép.</p>
          </div>
        </div>

        <div class="my-4 p-3 bg-white rounded box-shadow">
          <h5 class="border-bottom border-gray pb-2 mb-0">Cache Proxy</h5>
          <div class="text-dark pt-3">
            <p>Cache Proxy dùng để cung cấp không gian lưu trữ tạm thời cho các kế quả trả về của 1 đối tượng nào đó. Kết quả này
            sẽ được tái sử dụng cho các Client chia sẻ cùng 1 yêu cầu gửi đến. Về mặt bản chất thì cái này hơi hơi giống với flyweight. </p>
            Nó khác với Virtual Proxy ở điểm, virtual Proxy tạo ra 1 đối tượng trung gian để truy cập, còn nó là sử dụng để cache. Hai mục đích
            hoàn toàn khác nhau nhé.

          </div>
        </div>

      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">
        <p>Việc implement cần tuân thủ các bước sau:</p>

        <ul>
          <li>Xác định leverage hoặc aspect được triển khai tốt nhất dưới dạng bao bọc (wrapped) haowjc thay thế (surrogate)</li>
          <li>Xác định 1 interface giúp cho proxy và component ban đầu có thẻ thay đổi cho nhau.</li>
          <li>Xem xét việc xác định 1 Factory có thể gói gọn quyết định 1 Proxy hay original Object là móng muốn</li>
          <li>Tạo 1 Wrapper class giữ 1 con trỏ đến real class và implement interface kia.</li>
          <li>Con trỏ có thể được khởi tạo khi xây dựng hoặc sủ dụng lần đầu.</li>
          <li>Mỗi wrap method đóng góp leverage và ủy thác cho dối tượng wrappee.</li>
        </ul>


        <img src="../assets/design_pattern/uml_diagram/proxy_pattern_uml_diagram.jpg" class="img-fluid">

        <p>Việc implement nó có lẽ ko có gì quá phức tạp nên ta không đi vào chi tiết, thay vào đó, ta sẽ phân tích vào
          3 mục đích chính mà nó được sử dụng như sau:</p>

      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages
      </div>

      <div class="card-body">
        <h5>Advantages</h5>

        <p>Tùy thuộc vào từng loại proxy mà ta có những ưu điểm mà nó mang lại. Ví dụ</p>

        <p>Visual Proxy cung cấp cách thức để truy cập vào các đối tượng public của hệ thống thông qua một proxy pool nhằm tiết kiệm tài nguyên</p>

        <p>Protected Proxy cung cấp cơ chế bảo mật nhằm đảm bảo tính an toàn của hệ thống.</p>

        <p>Remote Proxy cung cấp cách thức giao tiếp với các hệ thống khác để đạt được mục đích.</p>

        <p>Smart Proxy cung cấp thêm các lớp bảo mật bổ sung bằng cách can thiệp vào các hành dộng cụ thể khi đối tượng
        được truy cập.</p>

        <h5>Disadvantages</h5>

        <p>__________</p>

        <h5>Usage</h5>

        <p>Khi ta cần bảo vệ quyền truy cập vào 1 object nào đó.</p>

        <p>Khi ta cần xây dựng 1 hệ thống lazy load để cải thiện hiệu năng</p>

        <p></p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Summary
      </div>

      <div class="card-body">
        <p>Proxy có nhiệm vụ cung cấp 1 người đại diện hoặc 1 người giữ chỗ vcho 1 đối tượng để quản lý quyền truy cập vào đối tượng đó.</p>

        <p>Sử dụng một mức độ bổ sung để hỗ trợ truy cập phân tán, kiểm soát thông minh</p>

        <p>Sử dụng Wrapper và delegation (ủy quyền) để bảo về cấc thành phần khỏi những sự phức tạp không đáng có.</p>

        <p>Phân biệt Proxy Pattern với các Pattern khác:</p>

        <p>Đối với Proxy Pattern, cách thức của nó là tạo thành 1 lớp bảo vệ. Lớp bảo vệ này thường sẽ wrapper lại command của Object
        và quyết định sẽ xử lý nó như thế nào.</p>

        <p>Trong khi đó, Adapter là việc xây dựng 1 Interface để tương thích với 1 Interface đã có. Về mặt mục đích là hoàn toàn khác nhau.</p>

        <p>Decorate và Proxy cũng khác nhau về mặt mục đích, nhưng chúng có thể có 1 điểm chung ở vấn đề thiết kế, vì cùng sử dụng
        Wrapper.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Important things
      </div>

      <div class="card-body">
        <p>Adapter cung cấp 1 giao diện khác cho subject, trong khi dó Proxy cung cấp 1 interface tương tự, Decorate cung cấp 1 interface nâng cao./</p>

        <p>Proxy và Decorate có mục đích khác nhau cnhuwng có cấu trúc tương tự. Cả 2 đều mô tả làm thế nào để cung cấp 1 mức độ gián tiếp
        cho 1 đối tượng và việc triển khai giữ 1 tham chiếu đến đối tượng mà họ chuyển tiếp yêu cầu.</p>
      </div>
    </div>
  </div>
</div>
