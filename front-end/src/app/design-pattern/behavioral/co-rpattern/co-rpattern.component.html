<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Chain of Responsibility Pattern - Structural Pattern</h2>

      <p>Tránh việc Sender gửi request tới Receive bẳng cách cho nhiều đối tượng cơ hội xử lý yêu cầu. Xâu chuỗi
      các đối tượng nhận và chuyển yêu cầu dọc theo chuỗi cho đến khi 1 đối tượng xử lý nó.</p>

      <p>Yêu cầu khởi chạy lại và để lại với 1 đường dẫn có chứa nhiều trình xử lý có thể</p>

      <p>Một danh sách liên kết đối tượng với duyệt đệ quy. </p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Một ví dụ đơn giản của Chain of responsibility - Chuỗi trách nhiệm, đó là thư chuyền tay.</p>

        <p>Thư chuyền tay là cái trò mà lũ học sinh nào cũng khoái dùng. Bạn viết 1 lá thư, và muốn gửi cho một cô gái ngồi bàn đầu trong giờ học.</p>

        <p>Tất nhiên bạn ko thể chạy lên và đưa trực tiếp cho cô ấy được rồi. Thay vào đó, bạn ghi tên của cô gái lên đó, và đưa lên cho cậu bạn ngồi bàn trên.</p>

        <p>Cậu bạn ấy sẽ nhìn lên lá thư, và biết sẽ phải chuyển nó đến đâu. Và vậy là từ từ lá thư của bạn cũng đến đc. Khi cô ấy nhìn lên lá thư, thấy tên mình, cô ấy sẽ
          ngạc nhiên mở ra và đọc nó.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Đó là một ví dụ nho nhỏ về Chain of responsibility.</p>

        <p>Mục đích của Chain of Responsibility đó là làm hệ thống lỏng lẻo hơn. Cùng xem xét nhé:</p>

        <p>Giả sử hệ thống của bạn được phục vụ cho một mục đích nào đó, ví dụ như thanh toán. Bạn yêu cầu khách hàng điền vào những thông tin đó, rồi gửi lên hệ thống và sau đó xử lý.</p>

        <p>Bạn thiết kế hệ thống dựa trên những yêu cầu đó, Gồm một chức năng post, một chức năng receive n process và một chức năng saving. Mọi thứ OK, ko có vấn đề gì cả.</p>

        <p>Một ngày đẹp trời, một khách hàng quen phàn nàn rằng, tôi mua hàng rất nhiều nhưng mỗi lần như vậy lại phải điền lại cái hồ sơ đó. Tại sao anh không lấy hoặc cung cấp cho tôi những
          chức năng để có thể sử dụng lại những thông tin cũ.</p>

        <p>Và ôi thôi, bạn nhận ra, hệ thống mình chỉ biết tuân thủ theo nguyên tắc như vậy, nó trở nên quá cứng nhắc và khó để thay đổi.</p>

        <p>Chain of Responsibility ra đời nhằm mục đích đó, thay vì việc thiết kế một flow theo tiêu chuẩn, nó lại cung cấp một chuỗi các service.</p>

        <p>Khi một request được gửi vào, Chuỗi sẽ xác định xem đối tượng/ service hiện tại có "trách nhiệm" xử lý nó hay không, nếu không nó sẽ giao đối tượng đó cho một service tiếp theo trong chuỗi.</p>

      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">
        <blockquote>
          avoid coupling the sender of a request to its receiver by giving multiple objects a chance to handle the request
        </blockquote>

        <p>Trong lập trình ta có thể gặp các bài toán, có 1 số lượng các đối tượng/ phần tử xyuwr lý, hoặc nút có khả năng thay đổi
        và 1 luồng các yêu cầu cần được xử lý. Ta cần phải xử lý hiệu quả các request này mà không cần quan tâm các mối quan hệ,
        các thứ tự ưu tiên, hay anh xạ yêu cầu tới xử lý.</p>

        <p>Chain of Responsibility là 1 chuỗi các Object thành các "đường ống"-pipe. và để khách hàng quyết định "launches and leaves"
          các request của họ tại đầu đường ống.
        </p>

        <p>Chain of Responsibility xâu chuỗi các đối tượng receiver lại với nhau, và sau đó chuyển bất cứ thông điệp nào từ
        đối tượng này sang đối tượng khác cho đến khi nó đến được một đối tượng có khả năng xử lý thông điệp.</p>

        <p>Số lượng và loại đối tượng không được biết đến trước. Chúng sẽ được cấu hành tự động. Cơ chế chainning
        sử dụng recursive component để cho phép hỗ trợ unlimitted number.</p>

        <p>Chain of Responsibility đơn giản hóa các kết nối giwuax các đối tượng. Thay vì Sender và Receive phải duy trì tham
        chiếu đến tất cả các ứng cử viên, thì giờ đây mỗi Senderchỉ giữ 1 tham chiếu duy nhất đến người đứng đầu chuỗi và
        mỗi Receive gữi 1 tham chiếu duy nhất cho người kế nhiệm trực tiếp trong chuỗi.</p>

        <p>Khi áp dụng Pattern này, cẩn đảm bảo tồn tại 1 "mạng lưới an toàn" để catch mọi request không được xử lý.</p>

        <p>Không sử dụng Chain of Responsibility khi mỗi yêu cầu chỉ được xử lý bởi 1 handle hoặc khi Client/Sender biết chính
        xác service object nào sẽ sử lý yêu cầu đó.</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">
        <p>Dưới đây là các bước cần phân tích khi tiến hành</p>

        <ul>
          <li>Đầu tiên, lớp cơ sở (base class/ main class) sẽ định nghĩa một "next" pointer. Mục đích của thằng này là liên kết giữa các
          Receive Object lại với nhau.</li>

          <li>Sau đó, các delivery class sẽ implement các "đóng góp"-contribution của nó để xử lý yêu cầu. Nói nôm na là implement
            nhiệm vụ của nó. Ngoài ra, nó còn phải giữ một tham chiếu tới Base Class.</li>

          <li>Khi một request được gửi đến Delivery Object, nếu nó không có nghĩa vụ/ không được implement việc handle request đó, nó
            sẽ dánh dấu request đó cần được "passed on", và gửi lại cho Base Class. Base Class nhận được request này, nó sẽ tiếp tục chuyển request đó đến
             cho một delivery tiếp theo và cứ như vậy request sẽ lần lượt đi từ thằng này sang thằng khác.</li>

          <li>Client/ third party tạo và liên kết 1 chuỗi các object/ delivery để phục vụ cho quá trình xử lý request của nó.</li>

          <li>Client launches & leaves các request với root of chain.</li>
        </ul>

        <p>Việc implements nó gồm có những điểm cần lưu ý:</p>

        <p>Các service phải được thiết kế nhằm 2 mục đích chính, xử lý request nếu như nó có trách nhiệm, và chuyển tiếp cho đối tượng khác.</p>

        <p>Vì vậy, ta xây dựng một object với những method đó, đồng thời tạo ra một pipe để lưu trữ nó.</p>

        <p>Và tất nhiên, request được gửi tới cho đối tượng đầu tiên của chuỗi rồi.</p>

        <p>Một ví dụ dễ thấy của CoR, đó là try catch. Bản chất của Try Catch, nếu nó có trách nhiệm xử lý exception đó
          (catch) thì nó sẽ xử lý, nếu không, nó ném exception lên cho cái đoạn function/ block trên kia để xử lý.</p>

        <p>Thêm 1 ví dụ nữa đó là máy ATM. ATM sẽ tùy vào số tiền mà quyết định bao nhiều tờ 500k, bao nhiêu tờ 200k, bao nhiêu
        tờ 100k để trả lại khách hàng</p>

        <p>Lưu ý, một request có thể được/ và thường được xử lý bởi nhiều Delivery Object. Mô hình làm việc của Chain of Responsibility
        là dựa trên các message. Mỗi object có vai trò xử lý 1 message. CoR sử dụng bài toán đệ quy. Vấn đề việc tìm xem đối tượng nào
        xử lý tiếp theo là do Main Class quy định. Còn việc sẽ xác định đối tượng nào xử lý request là do Delivery Object quy định thông qua việc trả
        lại/ thay đổi message.</p>

        <p>Giả sử ta có 1 Block với các Object A, B, C, D, E, F và 1 Root of Chain R. Khi 1 request c truyền vào, nó được gửi cho R.
        R chuyển tiếp nó lần lượt cho A, B, C. C nhận request, xử lý nó và trả về 1 message là b. R lại tiếp tục tìm trong list của mình các
        Object có nhiệm vụ handle nó, và nó lại tiếp tục được gửi cho B. B xử lý xong lại đối message thành f. F xử lý xong lại đổi message thành a.
        Đó mới là ý nghĩa thực sự của CoR.</p>

        <p>Trong CoR, các delivery không tương tác trực tiếp với nhau mà thông qua Root of Chain. và, Client cũng ko biết gì về các delivery. Điều nó
        cần làm đó là gửi request tới cho R và kệ R xử lý. Đó chính là điều khiến cho Chain of Responsibility mang tính lỏng lẻo.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages
      </div>

      <div class="card-body">
        <h5>Advantages</h5>

        <p>Sử dụng CoR làm cho ứng dụng trở nên lỏng lẻo, giảm tính kết nối/ kết dính</p>

        <p>Tăng thêm tính linh hoạt khi muốn add/assign resposibility cho các object. Chỉ việc tạo 1 Node và đưa vào thôi</p>

        <p>Cho phép 1 tập hợp các Class hoạt động như 1. Các sự kiện được tạo ra trong 1 class có thể được gửi cho các class
        khác với sự trợ giúp của composition.</p>

        <h5>Disadvantages</h5>

        <p>Nhược điểm lớn nhất của cái này đó là vòng lặp đệ quy. Điều này dẫn đến xảy ra các trường hợp 1 request được chuyển đi
        chuyển lại trong pipe mà không kết thúc được. Do đó, cần xem xét kĩ lưỡng khi áp dụng.</p>

        <p>Việc sử dụng đúng nó là 1 vấn đề. không phải lúc nào cũng có thể xài.</p>

        <h5>Usage</h5>

        <p>Khi có nhiều hơn 1 đối tượng có thể xử lý yêu cầu mà người xử lý không biết rõ nên dùng cái nào.</p>

        <p>Khi ta cần 1 nhóm các object để xử lý 1 request 1 cách tự dộng</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Summary
      </div>

      <div class="card-body">
        <p>Chain of Responsibility đơn giản hóa các kết nối giữa các Object. Thay vì người gửi và những người nhận phải duy trì tham
        chiếu đến các Receiver Candidate thì giờ đây, người gửi chỉ giữ 1 tham chiếu đến người đứng đầu chuỗi và mỗi người nhận chỉ
        giữ tham chiếu đến người kế nhiệm trực tiếp trong chuỗi.</p>

        <p>Khi sử dụng Chain of Responsibility ta cần đảm bảo phải tồn tại một safety net để có thể "catch" tất cả mọi yêu cầu mà không được
        xử lý.</p>

        <p>Điểm cuối cùng, cũng là điểm cần chú ý trong pattern này đó là nó không nên sử dụng trong trường hợp khi mỗi request chỉ được
        xử lý bởi 1 object hoặc khi client object bieets service nào sẽ handle request đó.</p>

        <p>Sử dụng Chain of Responsiblity phải cực kì cẩn thận. Nếu xài ko đúng thì cái request đó sẽ gửi vòng vòng và không hồi kết vì
        Chain of Responsibility sử dụng bài toán đệ quy.</p>
      </div>
    </div>
  </div>
</div>
