<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Abstract Factory Pattern - Creational Pattern</h2>

      <p>Bản chất của Abstract Factory đó là cung cấp một tập hợp các Factory có phụ thuộc hoặc liên quan với nhau.</p>

      <p>Chia nhỏ các Factory thành từng cụm có liên quan, và sử dụng các interface để get các cụm đó.</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Cũng vẫn là cái cửa hàng ở góc phố kia. Sau một thời gian kinh doanh, nó đã trở nên sầm uất và phát triển hơn bao giờ hết.</p>

        <p>Ông chủ cửa hàng khá là hài lòng, nhưng vẫn mong muốn nó sẽ phát triển hơn nữa. Ông quyết định mở rộng thực đơn của mình
          để có thể đáp ứng cho nhu cầu ẩm thực của khác hàng. Để tạo đa dạng món ăn, ông quyết định sẽ xây dựng thực đơn theo ngày và thực đơn đặc biệt.</p>

        <p>Ông tuyển thêm một đống bếp phó và để anh bếp trưởng kia quản lý. Giờ thì anh bếp trưởng ko cần thiết phải nấu ăn nữa, mà đã lên chức thành người giám sát rồi.</p>

        <p>Nhưng mà vấn đề ở đây, khách hàng vào nhộn nhịp, việc cung ứng nguyên liệu của anh phụ tá kia không kịp.</p>

        <p>Và tất nhiên, điều này khiến ông chủ ko hài lòng rồi.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Danh sách món ăn có rồi, tại sao ta không phân loại chúng ra, khi nào cần thì ta sẽ cung ứng toàn bộ. Thay vì việc phải lấy từng quả trứng, miếng thịt bò, ít rau củ như
          trước kia, thì giờ anh phụ bếp chỉ cần để chúng vào 1 cái khay, và khi nào cần thì mang lên ngay cho anh bếp trưởng.</p>

        <p>Thế là, từ sáng sớm, anh phụ bếp hí húi xem cái danh sách, phân loại thành các nguyên liệu cho từng món ăn, rồi lúc khách hàng gọi, thì anh mang ngay vào cho mấy anh đầu bếp.</p>

        <p>Tiến độ công việc giờ đã nhanh hơn, mà việc quản lý nguyên liệu cũng dễ dàng hơn trước, vì toàn bộ đã có anh phụ bếp nắm rồi.</p>

        <p>Anh phụ bếp bây giờ, đã trở nên cao cấp hơn. Từ một Factory đơn giản, chỉ biết cung cấp trứng,
          thịt, thì giờ anh trở thành Abstract Factory - cung cấp được cả thực đơn.</p>

        <p>Sau này nếu như cửa hàng mở rộng, ông chủ tuyển thêm 1 đội ngũ giúp việc phụ anh, thì công việc
          của anh sẽ nhàn hơn nhiều, chỉ cần ngồi chờ ngta bưng các nguyên liệu tới, và đem nó cho các
          đầu bếp là xong, ko cần vất vả ngồi xếp từ đầu như trước nữa.</p>

        <p>Nếu như Factory quản lý việc tạo ra một bộ phận/ thuộc tính của đối tượng, thì abstract factory có vẻ nghiêng về việc nó dùng để tạo ra các đối tượng riêng biệt hơn. Trong ví dụ này, rõ ràng
          thực đơn món chính sẽ khác với thực đơn tráng miệng, mặc dù nó cũng được cấu tạo từ nước, đường, trứng, thịt này nọ.</p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">

        <blockquote>
          Abstract Factory Pattern says that just define an interface or abstract class for creating families of related
          (or dependent) objects but without specifying their concrete sub-classes.
        </blockquote>

        <blockquote>
          An Abstract Factory Pattern is also known as Kit.
        </blockquote>
        
        <p>Abstract Factory là 1 dạng mở rộng của Factory. Nó ra đời khi ta cần gom các Factory lại với nhau để cho gọn 
          và code đồng nhất hơn trong hệ thống.</p>
        
        <p>Abstract Factory được sử dụng khi ta đã có quá nhiều Factory và những Factory này có liên quan với nhau ở một khía cạnh nào đó,
        ví dụ như 1 công thức chẳng hạn.</p>
        
        <p>Abstract Factory nhóm các Object có liên quan lại với nhau, để có thể gọi nó 1 cách thuận tiện nhất.</p>
        
        <p>Ví dụ ta có object A được tạo thành từ đống B1, C2, D5, E4, Object B được tạo thành từ B2, C3, D1, E2, thì lúc này thay vì
        việc ta phải gọi 4 cái Factory cho mỗi lần tạo cái Object A, thì ta dùng luôn 1 Abstract Factory mà có thể gọi tới 4 Factory để
        tạo ra 4 Object đó. </p>

        <p>Nếu ví dụ trên kia chưa đủ rõ ràng, ta sẽ sang 1 ví dụ khác có tính thực tiễn hơn.</p>

        <p>
          Giả sử ta có 1 nhà máy sản xuất xe của Yamha, với các nhà máy con của nó như sản xuất vỏ, sản xuất động cơ, sản xuất khung xe,
          sản xuất bánh xe chẳng hạn. Mỗi nhà máy lại có các nhà máy con, nhà máy sản xuất vỏ xe Sirius, vỏ xe NVX, ...., chẳng hạn.
        </p>

        <p>Giả sử ta cần build 1 cái xe Sirius, ta gọi các Factory sản xuất vỏ xe Sirius từ Factory Sản xuất vỏ xe, Factory sản xuất động cơ Sirius
          từ factory Sản xuất động cơ, ....</p>

        <p>Điều này mang lại những phiền hà không cần thiết. Việc sử dụng các Factory như vậy làm code của ta không những không sạch hơn mà còn khó hiểu
          hơn rất là nhiều.</p>

        <p>Thay vì như vậy, ta xây dựng 1 nhà máy sản xuất xe Sirius chẳng hạn, nhiệm vụ của nó là tự động đi vào trong các nhà máy kia, thu gom các Vật
          liệu cần thiết theo nhu cầu.</p>

        <p>Và từ đây công việc của bạn sẽ đơn giản hơn rất nhiều, vì ta chỉ cần gọi nhà máy sản xuất xe Sirius, và nó sẽ mang lại
          cho ta các linh kiện theo yêu cầu. Đó là mục đích chính của Abstract Factory</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">
        <p>Một abstract Factory gồm những thành phần sau :</p>

        <ul>
          <li>AbstractFactory : Định nghĩa một interface cho thao tác khởi tạo các Abstract Product</li>
          <li>ConcreteFactory : Thực thi Abstract Factory để cho ra một đối tượng cụ thể</li>
          <li>Factories </li>
        </ul>

        <p>Ví dụ: Ở đây ta đã có sẵn các Factory Trứng, Factory Rau, Factory Thịt này nọ rồi.</p>

        <p>Cửa hàng cung cấp thực đơn các món hầm gồm gà hầm nấm, bò hầm khoai tây, heo hầm đu đủ.</p>

        <p>Khách hàng vào yêu cầu món Bò hầm khoai tây, khi này anh phục vụ sẽ mang Bò từ Factory Thịt,
          Khoai tây, cà rốt từ Factory Rau lên cho anh đầu bếp.</p>

        <p>Khách hàng vào yêu cầu món Bò hầm khoai tây, nhưng phải là bò tót Tây Ban Nha, thì anh phục
          vụ sẽ vào lấy dĩa thịt trâu hôm qua cùng ít khoai tây mang cho anh đầu bếp.</p>

        <blockquote>
          Thay vì sử dụng if - else như trong Factory, đối với Abstract Factory, ta tạo ra 1 class để handle
          chuyện create object cho nó.<br />
          <br />
          <br />
          Nó cung cấp cách tiếp cận đến interface hơn là implements.<br />
          <br />
          Nó dễ dàng mở rộng từ các Factory đã có sẵn.<br />
          <br />
          Nó rất mạnh mẽ và tránh được điều kiện if-else của Factory.<br />
        </blockquote>

        <img src="assets/design_pattern/uml_diagram/abstractfactory_pattern_uml_diagram.jpg" class="img-fluid">
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages
      </div>

      <div class="card-body">
        <h5>Advantages</h5>

        <p>Abstract Factory cô lập client từ những concrete (implementation) classes</p>

        <p>Làm giảm bớt sự trao đổi của các familiar Objects (từ các Factory của nó) *</p>

        <p>Thúc đẩy sự nhất quán giữa các đối tượng.</p>

        <h5>Disadvantages</h5>

        <p>Nhược điểm của Abtract Factory đó là phải xác định được các nhóm Object. Xác định sai thì đi tong luôn.</p>


        <h5>Usage </h5>

        <p>Khi muốn tách việc khởi tạo Object ra khỏi hệ thống **</p>

        <p>Khi các đối tượng liên quan cần được sử dụng cùng với nhau </p>

        <p>Khi ta muốn cung cấp 1 library các objects nhưng không muốn show các implementations mà chỉ thông qua các interface</p>

        <p>Khi hệ thống cần được cấu hình với 1 trong nhiều family of objects.</p>


        <p class="small-text">
          * Vì sao ta bảo vậy. Giả sử ta có Factory A1 cung cấp các Object A1, Factory B1 cung cấp các object B1, A1, B1 là cùng
          kiểu.<br />
          Object A1 này được sử dụng dể tạo nên object và Object B1 dùng để tạo nên object B.

          Nếu như ta không xài cái Abstract Factory để giới hạn lại, thì có thể xảy ra 1 trường hợp, đó là khi tạo Object B,
          người ta vô tình dùng Factory A1. Do đó, việc sử dụng Abstract Factory để hạn chế sự trao đổi giữa các Family Class,
          bằng cách giới hạn lại nó theo đầu vào.
        </p>

        <p class="small-text">
          ** Tách việc khởi tạo ra khỏi hệ thống, tức là thay vì việc sử dụng toán tử new, ta sử dụng các Abstract Factory và các interface
          của nó để lấy ra Object cần tạo.
        </p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Summary
      </div>

      <div class="card-body">
        <p>Abtract Factory được sử dụng trong trường hợp ta có nhiều Object cùng 1 nhóm, mỗi object lại có các properties
          khác nhau và mỗi properties này lại được cung cấp bới các Factory khác nhau.</p>

        <p>Abstract Factory sẽ gom các Factory này lại, theo điều kiện của từng Object, và vì vậy mà ta sẽ có 1 cái Utils của Factory luôn.</p>

        <p>Thay vì sử dụng điều kiện if else, mỗi Object có 1 method để lấy các Factories của riêng nó. Method này cung cấp các factory mà nó cần.</p>
      </div>
    </div>
  </div>
</div>
