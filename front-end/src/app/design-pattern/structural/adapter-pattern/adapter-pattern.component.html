<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Adapter Design Pattern - Structural Pattern</h2>

      <p>Chuyển đổi giao diện của 1 lớp thành 1 giao diện khác mà client mong đợi. Adapter cho phép các class có thể làm việc
      cùng nhau bỏ qua vấn đề giao diện không tương thích.</p>

      <p>Bao bọc 1 lớp hiện có với 1 giao diện mới.</p>

      <p>Công cụ giúp cho 1 thành phần cũ có thể tương thích với 1 hệ thống mới</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Một ngày đẹp trời, ông chủ quyết định sẽ nâng cấp toàn bộ máy móc cho các anh đầu bếp. Ổng mua đâu được bên Nhật
          về một mớ hàng xịn, kêu thợ vận chuyển tới lắp đặt này nọ.</p>

        <p>Mọi việc sẽ ko có vấn đề gì nếu như : Nó chạy bằng điện 110v trong khi hệ thống điện của VN lại là 220v</p>

        <p>Và giờ làm sao để có thể sử dụng được những thiết bị này : Hay thôi trả nó lại và mất thêm một khoản phí kha khá.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Lên google search một hồi, Ổng quyết định ra tiệm điện gần nhà, mua một cái ổn áp, đầu vào 220v, đầu ra
          có thể là 110v hoặc 220v. Vậy là hệ thống thiết bị mới này sẽ được nối riêng ra, thông qua một cục chuyển áp.</p>

        <p>Cục chuyển áp kia là một ví dụ của Adapter.</p>

        <p>Mục đích của nó là làm cho các thiết bị/ interface không tương thích, có thể hoạt động/ giao tiếp với nhau.</p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">
        <blockquote>
          An Adapter Pattern says that just "converts the interface of a class into another interface that a client wants".
        </blockquote>

        <p>Reused là một trong những mục tiêu mà OOP nói riêng và các phương thức khác nói chung cố gắng tiếp cận đến. Điều gì sẽ xảy ra
        khi ta có 1 component với những chức năng tuyệt vời và muốn sử dụng lại nó nhưng hệ thống hiện tại lại ko cho phép ta làm điều đó.</p>

        <p>Adapter nói về việc tạo ra 1 intermediary abstraction có thể chuyển đổi hoặc ánh xạ 1 component cũ sang một hệt thống mới.</p>

        <p>Client gọi các phương thức trên đối tượng Adapter để chuyển hướng chúng thành các cuộc gọi tới lagacy component. Chiến lược
        này có thể được thực hiện bằng kế thừa (Object Adapter hoặc tổng hợp (Class Adapter)</p>

        <p>Adapter có chức năng như 1 trình bao bọc, wrapper hoặc sửa đổi, modifier một lớp hiện có. Kết quả là ta có 1 lớp mới
        với các phương thức khác hoặc chuyển đổi lớp hiện tại.</p>


        <p>Có hai loại Adapter phổ biến, Object Adapter và Class Adapter. Ví dụ về tờ giấy trên kia là một ví dụ về Object Adapter.</p>

        <dl>
          <dt>
            Class Adapter: sử dụng kế thừa và extend một interface nào đó
          </dt>

          <dd>
            Đối với trường hợp này, khi 1 class cha không tương thích với Interface A, ta sẽ tạo 1 thằng con Extend từ cái parent đó,
            thay đổi các Behavior để tương thích với cái Class đó.
          </dd>

          <dt>
            Object Adapter: sử dụng Java Composition
          </dt>

          <dd>
            Đối với trường hợp này, ta tạo 1 Composition riêng implement cái interface trên. Sau đó, ta "nhúng" nó vào các Class
            mà ta muốn và sử dụng nó để gọi cái interface tương ứng. Cách này hiệu quả hơn, vì khi đó ta sẽ có 1 reusable class
            và có thể biến bất cứ Class nào cũng có thể tương thích với interface mà ta muốn.
          </dd>
        </dl>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">
        <p>Để implement Pattern này, ta tuân thủ các bước sau:</p>

        <ul>
          <li>Xác định các đối tượng : Component muốn được cung cấp (Client) và thành phần cần thay đổi (Adaptee)</li>

          <li>Định nghĩa các interface mà client cần.</li>

          <li>Thiết kế 1 Wrap Class có thể impedance match adapter với Client.</li>

          <li>Adapter/Wrapper class maps client interface với adapter interface</li>

          <li>Client sử dụng / couple với new interface.</li>
        </ul>

        <p>Trong mô hình này, ta luôn có 2 đối tượng cần quan tâm, đối tượng sử dụng dịch vụ và đối tượng cần cung cấp. Từ
        các yêu cầu đề ra của đối tượng sử dụng dịch vụ, client mà ta thiết kế lại các adapter thỏa mãn yêu cầu đó.
        Bản chất của Adapter chỉ đơn giản là vậy.</p>

        <p>Như đã nói ở trên, có 2 cách implement cho trường hợp này. Dưới đây là chi tiết mô tả của 2 cách thức design cái Adaptee đó.</p>

        <p>Class Adapter: Triển khai theo mối quan hệ IS-A</p>

        <p>Object Adapter: Triển khai theo mối quan hệ HAS-A</p>

        <img src="../assets/design_pattern/uml_diagram/adapter_pattern_uml_diagram.jpg" class="img-fluid">

        <p>Cái chức năng PlayMedia.js trong Sadlier là 1 ví dụ của Object Adapter.</p>

        <p>Việc đầu tiên, ta quan tâm tới behavior của cái media, nó có thể là audio, video, ta ko cần quan tâm. Ta chỉ quan tâm
        tới các behavior của nó. Ví dụ renderLayout, play, pause, stop, changeVolume, changeToFullScreenMode. Từ những method này ta định ra được các behavior
        tương ứng.</p>

        <p>Sau đó, ta tạo 1 object MEDIA_UTILS bên trong cái Object Util của ta, quyết định sẽ new audioPlayer hay videoPlayer
        thông qua 1 factory.</p>

        <p>Và đổi các event của cái Util này thành MEDIA_UTILS.callTheMethod mà thôi.</p>

        <p>JS khó viết oop hơn là TS nên cần cẩn thận khi xài nó, ko thì sẽ có những thứ ko chạy được :)</p>

        <p>Lưu ý, audio không có fullScreen nhưng ta vẫn cần phải implement method này cho nó, nhưng tốt nhất là cho return false.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages and Usage
      </div>

      <div class="card-body">
        <h5>Advantages</h5>

        <p>Reused lại hệ thống cũ mà không cần implement lại quá nhiều</p>

        <h5>Disadvantages</h5>

        <p>Có thể có những adapter không thể tương thích được. Trong trường hợp này cần thay đổi cách giải quyết.</p>

        <h5>Usage</h5>

        <p>Muốn sử dụng lại 1 component trong 1 hệ thống đã có.</p>
        <p>Mở rộng class hiện tại nhưng không muốn làm thay đổi nó.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Important things
      </div>

      <div class="card-body">
        <p>Adapter làm cho mói thứ hoạt động sau khi nó được thiết kế. Trong khi đó, Bridge làm cho mọi thứ hoạc động trước
        khi nó tồn tại. Lưu ý, Bridge tách tính trừu tượng ra khỏi implement của nó, vì vậy, trước khi Object được thiết kế
        xong thì cái interface kia đã hoạt động rồi.</p>

        <p>Bridge được thiết kế up-front để cho sự trừu tượng (abstraction) và sự triển khai implement có thể thay đổi một cách độc lập.
        Trong khi đó, Adapter được trang bị thêm để giúp cho các class không liên quan có thể làm việc cùng với nhau.</p>

        <p>Adapter cung cấp 1 interface khác hoàn toàn với Subject của nó. Proxy cung cấp 1 giao diện tương tự. Decorate cung cấp
        1 giao diện nâng cao.</p>

        <p>Adapter thay đổi giao diện của 1 đối tượng hiện có. Decorate tằng thêm 1 đối tượng khác mà không làm thay đổi interface
        của nó. Do đó, Decorator minh bạch hơn cho Application hơn là Adapter. Kế quả, Decorate thường được hỗ trợ cho các thành phần
        đệ quy, đây là điều không thể với Adapter.</p>

        <p>Facade định nghĩa 1 giao diện mới, trong khi Adapter sử dụng lại 1 giao diện cũ. Lưu ý, Adapter giúp cho 2 giao diện có thể
        làm việc với nhau, thay vì xác định 1 giao diện hoàn toàn mới.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        IS-A and HAS-A in OOP.
      </div>

      <div class="card-body">
        <p>
          IS-A là mối quan hệ cha - con, trong đó thằng mới được extends từ thằng ban đầu.<br />
          Trong mối quan hệ này, thì thằng mới kia có thể override các method của thằng cha lại cho phù hợp
          với ngữ nghĩa của nó.
        </p>

        <p>
          HAS-A thì sử dụng cách khác, nó đưa thằng cha vào làm một properties của thằng mới<br />
          Thằng mới chỉ có thể sử dụng lại các method của thằng ban đầu
        </p>
      </div>
    </div>
  </div>
</div>
