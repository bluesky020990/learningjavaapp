<div class="row mb-3">
  <div class="col-12">
    <div class="overview-container">
      <h2 class="mb-3">Factory Pattern - Creational Pattern</h2>

      <p>Factory pattern che dấu hoàn toàn việc khởi tạo object, ta không thể sử dụng toán tử new để lấy được object
        mà ta muốn, thay vào đó, Factory sẽ cung cấp cho ta 1 interface để làm việc đó.</p>

      <p>Factory Pattern được dùng trong trường hợp ta có một nhóm object, và muốn code trở nên thống nhất đồng thời
        che dấu đi việc khởi tạo của chúng. Client chỉ cần gọi interface với tham số mà ta cung cấp, và mọi thứ sẽ ok hết thôi.</p>

      <p>Tóm lại, nó là một Factory - Nhà máy - và nhiệm vụ của nó là sản xuất object.</p>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Bài toán
      </div>

      <div class="card-body">
        <p>Ở nhà hàng nọ có 1 anh đầu bếp rất tài ba. Vì khả năng nấu nướng tuyệt vời của mình nên lúc
          nào cửa hàng của anh cũng đông khách. Anh luôn phải tất bật làm việc, từ đi chuẩn bị rau củ, đến
          rã đông cá cua,  rồi băm chặt đủ thứ.</p>

        <p>Cửa hàng ngày càng đông, sức anh ko làm được. Thế là một hôm, anh mới than phiền với ông chủ
          về điều này.</p>

        <p>Và ông chủ hứa sẽ tuyển cho anh một trợ lý.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Giải pháp
      </div>

      <div class="card-body">
        <p>Trợ lý của anh chả biết gì về ẩm thực. Tất nhiên, tiền thuê đầu bếp lúc nào cũng rẻ hơn tiền
          thuê đứa rửa bát mà. </p>

        <p>Và nhiệm vụ của nó là sẵn sàng cung cấp cho anh các loại thực phẩm mà anh cần. Anh chỉ việc
          yêu cầu và nó sẽ mang tới cho anh chỉ sau vài giây.</p>

        <p>Từ đó, anh đầu bếp chỉ hí húi bên cái bếp lửa của mình và mọi việc còn lại đã có anh phụ bếp
          này lo.</p>

        <p>Anh trợ lý / phụ bếp này chính là Factory.</p>

        <p>Trong lập trình cũng vậy, có đôi khi ta có quá nhiều object, và ta muốn quản lý việc khai báo
          chúng, khi đó ta sử dụng Factory như một anh trợ lý, để cung cấp các object theo yêu cầu.</p>

        <p>Nếu như cửa hàng mở rộng thêm, và ông chủ tuyển thêm một anh đầu bếp khác nữa, thì anh ta
          cũng
          chỉ cần quan tâm tới việc nấu nướng của mình, còn việc cung ứng nguyên liệu, vẫn là do anh
          phụ
          bếp này quản lý. Và khi anh ấy yêu cầu Trứng gà, thì chắc chắn anh ta ko mất thời gian để đi
          tìm nó giữa la liệt đống trứng ngỗng. </p>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Introduction
      </div>

      <div class="card-body">
        <p>
        Factory Pattern là một trong những pattern phổ biến nhất trong lập trình hướng đối tượng.
      </p>

      <p>Nhiệm vụ của nó là quản lý và trả về các đối tượng theo yêu cầu, giúp cho việc khởi tạo đối
        tượng
        một cách linh hoạt hơn.</p>

      <p>Bản chất của Factory là <b>Định nghĩa một giao diện (interface) cho việc tạo một đối tượng,
        nhưng
        để các lớp con quyết định lớp nào sẽ được tạo. <i>Factory method</i> giao việc khởi tạo đối
        tượng cụ thể
        cho lớp con.</b></p>

      <p>Nói giao việc khởi tạo cho lớp con, ko có nghĩa là có cái lớp con nào đó và override cái method đó,
        mà lớp con sẽ sử dụng interface + danh sách các tham số mà Factory cung cấp, và quyết định xem nó muốn cái gì.</p>

      <p>Tức là nó kêu, tao muốn trứng gà, thì nó gọi interface + "trung-ga" chẳng hạn.</p>
      
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Implements
      </div>

      <div class="card-body">

        <p>Nhóm các object cùng chức năng thành một loại, có thể dụng Abstract Class hoặc Interface</p>

        <p>Xây dựng một Factory để lấy ra một object trong nhóm đó, tùy thuộc vào tham số truyền
          vào.</p>

        <p>Ví dụ, ta xếp trứng gà, trứng vịt, trứng ngỗng, trứng khủng long vào cùng một rổ. Mỗi khi anh
          đầu bếp yêu cầu trứng gà, thì anh
          trợ lý sẽ vào và lấy quả trưng theo yêu cầu ra. </p>


        <p>Ta thường sử dụng Factory khi mà chúng ta có 1 super class và multiple sub-classes. Và tùy
          theo input truyền vào, ta cần phải trả lại 1 trong số các subclass ở trên kia.</p>

        <p>Factory pattern mang nhiệm vụ instance của class từ client đến Factory. Và việc của bạn còn
          lại  rất đơn giản, getFactoryObjectByType, và nó sẽ trả ra object mà bạn cần.</p>

        <p>Dưới đây là mô tả về việc implement của nó</p>

        <ul>
          <li>Super class - Có thể là interface / abstract</li>
          <li>Subclass -- Các class implements interface trên kia / extend từ abstract class trên  kia. </li>
          <li>Factory Class với một static method handle việc initialize và return lại subclass từ tham số client truyền vào </li>
        </ul>

        <img src="assets/design_pattern/uml_diagram/factory_pattern_uml_diagram.jpg" class="img-fluid">

        <p>Những lưu ý thêm về việc implement pattern này:</p>

        <ul>
          <li>Bản chất của Factory pattern là quản lý việc khởi tạo các object. Vì vậy ta nên khai báo
            private cho constructor của subclass để ngăn cho nó không được khởi tạo từ bên ngoài của
            Factory.</li>

          <li>Factory class được sử dụng như một Utils Class (utils - sử dụng). Vì vậy ta nên biến cái
            Factory
            Class thành một Singleton Class / hoặc khai báo static cho cái method getFactoryObjectByType
            của nó
            để có thể sử dụng ở bất cứ đâu.</li>
        </ul>

        <p>Nói thêm về việc che dấu constructor của Class.</p>

        <ul>
          <li>Cách che dấu constructor của Class chỉ có thể thực hiện bằng cách khai báo private cho Constructor.
            Lúc này sẽ ko có bất cứ 1 Class nào có thể khởi tạo Class này bằng từ khóa new được cả.</li>

          <li>Vậy làm sao để get được Object đó. Trong Object ta khai báo 1 method static, mà method này sẽ gọi tới cái private constructor kia.
            Khi này ta đã vô tình khiến cho việc create Object chỉ được thực hiện thông qua cái method static của ta.</li>

          <li>Tiếp theo nữa ta tạo 1 Factory với cái tham số cần thiết, rồi dùng cái static method đó để khởi tạo Object dựa trên
          tham số đầu vào.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Advantages & Disadvantages
      </div>

      <div class="card-body">
        <p>Ưu điểm của Factory là dễ dàng thấy được. Nó che dấu đi logic khởi tạo của 1 đối tượng. Người dùng chỉ cần
        gọi thông qua 1 interface của Factory cung cấp mà thôi.</p>

        <p>Mục đích của Factory là che dấu việc khởi tạo của các đối tượng và chỉ cung cấp 1 cách thức duy nhất thông qua Factory.
        Tuy nhiên nếu ta ko che dấu đi các constructor, hoặc bằng 1 cách nào đó mà có thể create Instance mà không thông
        qua Factory thì nguyên tắc này sẽ bị phá vỡ.</p>

        <p>Việc khởi tạo các Object thông qua điều kiện của Tham số truyền vào trong factory nhiều khi không đủ. Với các
        object có việc khởi tạo phức tạp, ta cần thông qua Builder Pattern để đạt được điều này.</p>
      </div>
    </div>
  </div>
</div>


<div class="row mb-3">
  <div class="col-12">
    <div class="card">
      <div class="card-header">
        Summary
      </div>

      <div class="card-body">
        <p>Factory che dấu việc khởi tạo các Object và cung cấp 1 interface để cung cấp các Object này như 1 biện pháp thay thế.</p>

        <p>Cần implement đúng để tránh trường hợp có thể khởi tạo 1 Object mà ko thông qua các Factory. Điều này sẽ khiến cho mục đích
        của Pattern bị phá vỡ.</p>

        <p>Factory không giải quyết được bài toán cần khởi tạo 1 Object phức tạp, có nhiều tham số truyền vào. Thay vào đó, ta phải sử dụng Builder để thay thế.</p>
      </div>
    </div>
  </div>
</div>
